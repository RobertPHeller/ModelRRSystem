#* 
#* ------------------------------------------------------------------
#* XPressNetThrottle.src - XPressNet Throttle Program
#* Created by Robert Heller on Mon Mar 26 13:11:29 2012
#* ------------------------------------------------------------------
#* Modification History: $Log$
#* Modification History: Revision 1.1  2002/07/28 14:03:50  heller
#* Modification History: Add it copyright notice headers
#* Modification History:
#* ------------------------------------------------------------------
#* Contents:
#* ------------------------------------------------------------------
#*  
#*     Model RR System, Version 2
#*     Copyright (C) 1994,1995,2002-2012  Robert Heller D/B/A Deepwoods Software
#* 			51 Locke Hill Road
#* 			Wendell, MA 01379-9728
#* 
#*     This program is free software; you can redistribute it and/or modify
#*     it under the terms of the GNU General Public License as published by
#*     the Free Software Foundation; either version 2 of the License, or
#*     (at your option) any later version.
#* 
#*     This program is distributed in the hope that it will be useful,
#*     but WITHOUT ANY WARRANTY; without even the implied warranty of
#*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*     GNU General Public License for more details.
#* 
#*     You should have received a copy of the GNU General Public License
#*     along with this program; if not, write to the Free Software
#*     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#* 
#*  
#* 

# $Id: UniversalTest.src 929 2011-05-12 17:35:57Z heller $

## @defgroup XPressNetThrottle XPressNetThrottle
#  @brief XPressNet Throttle Program
#
# @section SYNOPSIS
#
# XPressNetThrottle [X11 Resource Options] [SerialPort]
#
# @section DESCRIPTION
# 
# This program is a GUI program that implements a software / computer screen
# throttle device for XPressNet.  Both train / accessory operation and 
# programming functions are implemented.
# 
# The use of this program is fully described in the <em>Model Railroad
# System User Manual</em>, in Part I.
#
# 
# @section PARAMETERS
#
# @arg SerialPort The serial port to use to connect to the XPressNet bus. If
# not supplied, it will be prompted for.
#  
# @section AUTHOR 
# Robert Heller \<heller\@deepsoft.com\>
#

set argv0 [file join  [file dirname [info nameofexecutable]] XPressNetThrottle]

package require Xpressnet

package require gettext
package require Tk
package require BWidget
package require BWStdMenuBar
package require HTMLHelp
package require BWLabelComboBox
package require BWLabelSpinBox
package require CabWidgets

global HelpDir
set HelpDir [file join [file dirname [file dirname [file dirname \
							[info script]]]] Help]
#puts stderr "*** HelpDir = $HelpDir"
set msgfiles [::msgcat::mcload [file join [file dirname [file dirname [file dirname \
							[info script]]]] Messages]]
#puts stderr "*** msgfiles = $msgfiles"

namespace eval XPressNetThrottle {
  variable InstructionQueue {}
  snit::integer ubyte -min 0 -max 255
  snit::integer cvnumber -min 1 -max 256
  snit::widget SingleCV {
    delegate option -name to le as -label
    option -command -default {}
    option -number  -default 1 -type XPressNetThrottle::cvnumber
    delegate option -labelwidth to le
    delegate option -writable to le as -editable
    component le
    constructor {args} {
      install le using LabelEntry $win.le \
			-command [mymethod _ecommand] -text {0}
      pack $le -fill x
      $self configurelist $args
    }
    method value {} {
      return [$le cget -text]
    }
    method _ecommand {} {
      set v [$le cget -text]
      if {[catch {XPressNetThrottle::ubyte validate $v}]} {
	tk_messageBox -type ok -icon error -message [_ "Not an 8bit integer: %s" $v]
	return
      }
      $self invoke
    }
    method invoke {} {
      set cmd [concat $options(-command) [$self cget -number] [$self value]]
      uplevel #0 $cmd
    }
    method setvalue {v} {
      puts stderr "*** $self setvalue $v"
      if {[catch {XPressNetThrottle::ubyte validate $v}]} {
        tk_messageBox -type ok -icon error -message [_ "Not an 8bit integer: %s" $v]
	return
      }
      $le configure -text $v
    }
  }
  snit::integer address -min 0 -max 0x27ff
  snit::widget LongAddress {
    option -command -default {}
    delegate option -labelwidth to le
    component le
    constructor {args} {
      install le using LabelEntry $win.le -label [_m "Label|Extended Address"] \
			-command [mymethod _ecommand] -text {0}
      pack $le -fill x
      $self configurelist $args
    }
    method value {} {
      return [$le cget -text]
    }
    method _ecommand {} {
      set v [$le cget -text]
      if {[catch {XPressNetThrottle::address validate $v}]} {
	tk_messageBox -type ok -icon error -message [_ "Not an address: %s" $v]
	return
      }
      $self invoke
    }
    method invoke {} {
      set cmd [concat $options(-command) [$self value]]
      uplevel #0 $cmd
    }
    method setvalue {v} {
      puts stderr "*** $self setvalue $v"
      if {[catch {XPressNetThrottle::address validate $v}]} {
        tk_messageBox -type ok -icon error -message [_ "Not an address: %s" $v]
	return
      }
      $le configure -text $v
    }
  }
}

proc XPressNetThrottle::MainWindow {} {

  # Window manager configurations
  wm minsize . 300 1
  wm protocol . WM_DELETE_WINDOW {CareFulExit}
  wm title . [_ "XPressNet Throttle Program"]

  set menubar [StdMenuBar::MakeMenu \
	-file [list [_m "Menu|&File"] {file} {file} 0 [list \
	        [list command [_m "Menu|File|E&xit"] {file:exit} [_ "Exit the application"] {} -command {XPressNetThrottle::CareFulExit}] \
		] \
	] -help [list [_m "Menu|&Help"] {help} {help} 0 [list \
		[list command [_m "Menu|Help|On &Help..."] {help:help} [_ "Help on help"] {} -command "HTMLHelp::HTMLHelp help Help"]\
		[list command [_m "Menu|Help|On &Version"] {help:version} [_ "Version"] {} -command "HTMLHelp::HTMLHelp help Version"]\
		[list command [_m "Menu|Help|Warranty"] {help:warranty} [_ "Warranty"] {} -command "HTMLHelp::HTMLHelp help Warranty"]\
		[list command [_m "Menu|Help|Copying"] {help:copying} [_ "Copying"] {} -command "HTMLHelp::HTMLHelp help Copying"]\
		[list command [_m "Menu|Help|Reference Manual"] {help:reference} [_ "Reference Manual"] {} -command {HTMLHelp::HTMLHelp help "Universal Test Program Reference"}]\
		] \
        ]]

  variable Main [MainFrame .main -menu $menubar \
	-progressmax 100 -progresstype normal -progressvar ::progress \
	-textvariable status \
	-separator both]
  pack $Main -expand yes -fill both
  $Main showstatusbar progression

  variable MainFrame [$Main getframe]

  HTMLHelp::HTMLHelp setDefaults "$::HelpDir" "XPressNetThrottleli1.html"
  set tf [labelframe $MainFrame.tf -text "Communications Log:"]
  pack $tf -expand yes -fill both
  pack [ScrolledWindow $tf.sw -auto both -scrollbar both] \
		-fill both -expand yes
  variable Response
  $tf.sw setwidget [text [set Response [$tf.sw getframe].response] \
				  -height 5]

  pack [Button $tf.clear -text "Clear Communications Log" \
			-command "$Response delete 1.0 end"] -fill x
  variable NoteBook [NoteBook $MainFrame.noteBook -side top]
  pack $NoteBook -expand yes -fill both
  
  variable Throttle [$NoteBook insert end throttle \
			-raisecmd XPressNetThrottle::ResumeNormal \
			-text "Throttle Mode"]
  set speedanddir [labelframe $Throttle.speedanddir \
			-text [_m "Label|Address, Speed, and Direction"]]
  grid columnconfigure $Throttle 0 -weight 1
  grid columnconfigure $Throttle 1 -weight 4
  grid $speedanddir -column 0 -row 0 -sticky news
  variable LocoAddress [::CabWidgets::SelectLocomotive $speedanddir.locoAddress \
				-command XPressNetThrottle::SelectLocomotive \
				-label [_m "Label|Address:"]]
  pack $LocoAddress -fill x
  variable LocoDirection [::CabWidgets::LocomotiveDirection $speedanddir.locoDirection]
  pack $LocoDirection -fill x
  variable LocoSpeed [::CabWidgets::LocomotiveSpeed $speedanddir.locoSpeed \
			-command XPressNetThrottle::ChangeLocomotiveSpeed]
  pack $LocoSpeed -fill y
  variable LocoSpeedStep [LabelComboBox $speedanddir.locoSpeedStep \
				-editable no -values {S14 S27 S28 S128} \
				-label "Speed Steps:"]
  $LocoSpeedStep setvalue first
  pack $LocoSpeedStep -fill x

  variable LocoFunctions [labelframe $Throttle.locoFunctions -text [_m "Label|Functions"]]
  grid $LocoFunctions -column 1 -row 0 -sticky news
  variable Functions
  variable FGroup

  foreach f  [list 1   2  3  4  5  6  7  8  9  [_m "Label|0\nHead Light"] F10 F11 F12] \
	  n  {     f1 f2 f3 f4 f5 f6 f7 f8 f9  f0 f10 f11 f12} \
	  c  {     0   1  2  0  1  2  0  1  2  0  0   1   2} \
	  r  {     0   0  0  1  1  1  2  2  2  3  4   4   4} \
	  gr {     1   1  1  1  2  2  2  2  3  1  3   3   3} \
	  i  {     1   2  3  4  5  6  7  8  9  0  10  11  12} \
	  cs {     1   1  1  1  1  1  1  1  1  3  1   1   1} \
	  a  {     1   2  3  4  0  1  2  3  0  0  1   2   3} {	
    set b [Button $LocoFunctions.$n \
			-command [list XPressNetThrottle::toggleButton $i] \
			-text $f -font {Courier -32 bold}]
    grid $b -column $c -row $r -sticky news -columnspan $cs
    set Functions($i,group) $gr
    set Functions($i,arg)   $a
    set Functions($i,value) 0
    set Functions($i,button) $LocoFunctions.$n
    lappend FGroup($gr) $i
  }
  foreach g [array names FGroup] {
    set FGroup($g) [lsort  -command XPressNetThrottle::groupargorder $FGroup($g)]
  }

  variable Program  [$NoteBook insert end program -text "Programming Mode" \
				-raisecmd XPressNetThrottle::EnterProgrammingMode]

  variable TheManID [SingleCV $Program.theManID -number 8 -writable no \
			-name [_m "Label|Manufacturer ID"]]
  pack $TheManID -fill x
  variable TheManVersion [SingleCV $Program.theManVersion -number 7 -writable no \
			-name [_m "Label|Manufacturer Version No"]]
  pack $TheManVersion -fill x

  variable SelectCV [LabelComboBox $Program.selectCV \
	-label [_m "Label|Select a CV"] \
	-editable yes \
	-values [list \
	    [_m "Label|1 Primary Address"] \
	    [_m "Label|2 Vstart"] \
	    [_m "Label|3 Acceleration Rate"] \
	    [_m "Label|4 Deceleration Rate"] \
	    [_m "Label|5 Vhigh"] \
	    [_m "Label|6 Vmid"] \
	    [_m "Label|9 Total PWM Period"] \
	    [_m "Label|10 EMF Feedback Cutout"] \
	    [_m "Label|11 Packet Time-Out Value"] \
	    [_m "Label|12 Power Source Conversion"] \
	    [_m "Label|13 Alternate Mode Function Status F1-F8"] \
	    [_m "Label|14 Alternate Mode Function Status FL,F9-F12"] \
	    [_m "Label|15 Decoder Lock (Key)"] \
	    [_m "Label|16 Decoder Lock (Decode)"] \
	    [_m "Label|17 & 18 Extended Address"] \
	    [_m "Label|19 Consist Address"] \
	    [_m "Label|21 Consist Addr Active for F1-F8"] \
	    [_m "Label|22 Consist Addr Active for FL,F9-F12"] \
	    [_m "Label|23 Acceleration Adjustment"] \
	    [_m "Label|24 Deceleration Adjustment"] \
	    [_m "Label|25 Speed Table / Mid-range Cab Speed Step"] \
	    [_m "Label|27 Decoder Automatic Stopping Configuration"] \
	    [_m "Label|28 Bi-Directional Communication Configuration"] \
	    [_m "Label|29 Configuration Data #1"] \
	    [_m "Label|30 Error Information"] \
	    [_m "Label|31 Index High Byte"] \
	    [_m "Label|32 Index Low Byte"] \
	    [_m "Label|33 Output Loc. FL(f)"] \
	    [_m "Label|34 Output Loc. FL(r)"] \
	    [_m "Label|35 Output Loc. F1"] \
	    [_m "Label|36 Output Loc. F2"] \
	    [_m "Label|37 Output Loc. F3"] \
	    [_m "Label|38 Output Loc. F4"] \
	    [_m "Label|39 Output Loc. F5"] \
	    [_m "Label|40 Output Loc. F6"] \
	    [_m "Label|41 Output Loc. F7"] \
	    [_m "Label|42 Output Loc. F8"] \
	    [_m "Label|43 Output Loc. F9"] \
	    [_m "Label|44 Output Loc. F10"] \
	    [_m "Label|45 Output Loc. F11"] \
	    [_m "Label|46 Output Loc. F12"] \
	    [_m "Label|65 Kick Start"] \
	    [_m "Label|66 Forward Trim"] \
	    [_m "Label|95 Reverse Trim"] \
	    [_m "Label|105 User Identifier #1"] \
	    [_m "Label|106 User Identifier #2"] \
	] -command "XPressNetThrottle::DoSelectCV" \
	-modifycmd "XPressNetThrottle::DoSelectCV"]
  $SelectCV setvalue first
  pack $SelectCV -fill x
  variable ProgramPages [PagesManager $Program.pages]
  pack $ProgramPages -expand yes -fill both
  set single [$ProgramPages add single]
  variable TheSingleCV [SingleCV $single.singleCV -command "XPressNetThrottle::SetCV"]
  pack $TheSingleCV -fill x
  set address [$ProgramPages add address]
  variable TheLongAddress [LongAddress $address.longAddress -command "XPressNetThrottle::SetLongAddress"]
  pack $TheLongAddress -fill x

  set w .
  global IsSlave
  if {!$IsSlave} {
    wm withdraw $w
    update idletasks
    set rw [winfo reqwidth $w]
    if {$rw < 200} {set rw 300}
    set rh [winfo reqheight $w]
    set x [expr {[winfo screenwidth $w]/2 - $rw/2 \
            - [winfo vrootx $w]}]
    set y [expr {[winfo screenheight $w]/2 - $rh/2 \
            - [winfo vrooty $w]}]
    wm geom $w =${rw}x${rh}+$x+$y
    wm deiconify .
  }
  update idletasks
  wm minsize . [winfo reqwidth $w] [expr [winfo reqheight $w] + 35]
  bind all <q> XPressNetThrottle::CareFulExit
  bind all <Q> XPressNetThrottle::CareFulExit
}

proc XPressNetThrottle::CareFulExit {} {
# Procedure to carefully exit.
# [index] CarefulExit!procedure

  if {[string compare \
        [tk_messageBox -default no -icon question -message [_ "Really Quit?"] \
                -title [_ "Careful Exit"] -type yesno] {yes}] == 0} {
    global IsSlave
    #puts stderr "*** CarefulExit: IsSlave = $IsSlave"
    flush stderr
    if {$IsSlave} {
      puts stdout "101 Exit"
      flush stdout
      set ans [gets stdin]
      #puts stderr "*** CarefulExit: ans = '$ans'"
    }
    # Close XPressNet connection?
    exit
  }
}

proc XPressNetThrottle::EnterProgrammingMode {} {
  variable SelectCV
  variable ProgramPages

  QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead 7
  QueueInstruction XPressNetThrottle::XPressNetBus RequestForServiceModeResults
  QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead 8
  QueueInstruction XPressNetThrottle::XPressNetBus RequestForServiceModeResults
  DoSelectCV
}

proc XPressNetThrottle::DoSelectCV {} {
  variable SelectCV
  variable ProgramPages

  set selection [$SelectCV cget -text]
  if {[regexp {^([[:digit:]]+)} "$selection" => cv] > 0} {
    if {$cv == 17 || $cv == 18} {
      $ProgramPages raise address
      QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead 17
      QueueInstruction XPressNetThrottle::XPressNetBus RequestForServiceModeResults
      QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead 18
      QueueInstruction XPressNetThrottle::XPressNetBus RequestForServiceModeResults
    } else {
      if {[catch {XPressNetThrottle::cvnumber validate $cv}]} {
        tk_messageBox -type ok -icon error -message [_ "Not a valid CV number: %s" $cv]
	return
      }
      $ProgramPages raise single
      if {$cv == 256} {
	QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead 0
      } else {
	QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVRead $cv
      }
      QueueInstruction XPressNetThrottle::XPressNetBus RequestForServiceModeResults
      variable TheSingleCV
      $TheSingleCV configure -number $cv
      $TheSingleCV configure -name $selection
    }
  } else {
    tk_messageBox -type ok -icon error -message [_ "Not a valid CV number: %s" $selection]
  }
}
    
proc XPressNetThrottle::SetCV {index value} {
  puts stderr "*** XPressNetThrottle::SetCV $index $value"
  if {$index == 256} {
    QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVWrite 0 $value
  } else {
    QueueInstruction XPressNetThrottle::XPressNetBus DirectModeCVWrite $index $value
  }
}

proc XPressNetThrottle::SetLongAddress {value} {
  puts stderr "*** XPressNetThrottle::SetLongAddress $value"
  if {$value != 0} {
    set highbyte [expr {(($value >> 8) & 0x27) | 0x0c0}]
    set lowbyte  [expr {$value & 0x0ff}]
    puts stderr "*** XPressNetThrottle::SetLongAddress: highbyte = $highbyte, lowbyte = $lowbyte"
    SetCV 17 $highbyte
    SetCV 18 $lowbyte
  } else {
    SetCV 17 0
    SetCV 18 0
  }
}

proc XPressNetThrottle::ResumeNormal {} {  
  QueueInstruction XPressNetThrottle::XPressNetBus ResumeOperations
}

proc XPressNetThrottle::SelectLocomotive {address} {
  QueueInstruction XPressNetThrottle::XPressNetBus LocomotiveInformationRequest $address
}

proc XPressNetThrottle::ChangeLocomotiveSpeed {newspeed} {
  variable LocoSpeedStep
  variable LocoDirection
  variable LocoAddress
  set cmd [list QueueInstruction XPressNetThrottle::XPressNetBus SetLocomotiveSpeedAndDirection [$LocoAddress currentLocomotive]]
  set ssIndex [$LocoSpeedStep getvalue]
  set ssMode [lindex [$LocoSpeedStep cget -values] $ssIndex]
  lappend cmd $ssMode
  lappend cmd [$LocoDirection direction]
  
  switch $ssMode {
    S14 {lappend cmd [expr {int(($newspeed / 128.0) * 14)}]}
    S27 {lappend cmd [expr {int(($newspeed / 128.0) * 27)}]}
    S28 {lappend cmd [expr {int(($newspeed / 128.0) * 28)}]}
    S128 {lappend cmd $newspeed}
  }
  eval $cmd
}

proc XPressNetThrottle::ProcessResponse {type response} {
  variable Response
  variable MultiFunConfig
  variable InstructionQueue
  puts stderr "*** ProcessResponse $type $response"
  switch $type {
    NO_RESPONSE_AVAILABLE {}
    NORMAL_OPERATION_RESUMED {
	$Response insert end "Normal Operation Resumed\n"
    }
    TRACK_POWER_OFF {
	$Response insert end "Track Power Off\n"
    }
    EMERGENCY_STOP {
	$Response insert end "Emergency Stop\n"
    }
    SERVICE_MODE_ENTRY {
	$Response insert end "Service Mode Entry\n"
    }
    PROGRAMMING_INFO_SHORT_CIRCUIT {
	$Response insert end "Programming Info Short Circuit\n"
    }
    PROGRAMMING_INFO_DATA_BYTE_NOT_FOUND {
	$Response insert end "Programming Info Data Byte Not Found\n"
    }
    PROGRAMMING_INFO_COMMAND_STATION_BUSY {
	$Response insert end "Programming Info Command Station Busy\n"
    }
    PROGRAMMING_INFO_COMMAND_STATION_READY {
	$Response insert end "Programming Info Command Station Ready\n"
    }
    SERVICE_MODE_RESPONSE {
	puts stderr "*** ProcessResponse (SERVICE_MODE_RESPONSE): CV is [$response CV], Data is [$response Data]"
	variable TheSingleCV
	variable TheLongAddress
	variable TheManVersion
	variable TheManID
	set CV [$response CV]
	set Data [$response Data]
	if {$CV == 7} {
	  $TheManVersion setvalue $Data
	}
	if {$CV == 8} {
	  $TheManID setvalue $Data
	}
	if {$CV == 17} {
	  set addr [$TheLongAddress value]
	  set lbyte [expr {$addr & 0x0ff}]
	  set hbyte [expr {$Data & 0x027}]
	  set newaddr [expr {($hbyte << 8) | $lbyte}]
	  $TheLongAddress setvalue $newaddr
	} elseif {$CV == 18} {
	  set addr [$TheLongAddress value]
	  set lbyte [expr {$Data & 0x0ff}]
	  set hbyte [expr {($addr >> 8) & 0x027}]
	  set newaddr [expr {($hbyte << 8) | $lbyte}]
	  $TheLongAddress setvalue $newaddr
	} elseif {$CV == 0 && [$TheSingleCV cget -number] == 256} {
	  $TheSingleCV setvalue $Data
	} elseif {$CV == [$TheSingleCV cget -number]} {
	  $TheSingleCV setvalue $Data
	} else {
	  $Response insert end "Service Mode Response\n"
	  $Response insert end "  ServiceMode is [$response ServiceMode]\n"
	  $Response insert end "  CV is [$response CV]\n"
	  $Response insert end "  Data is [$response Data]\n"
	}
    }
    SOFTWARE_VERSION {
	$Response insert end "Software Version\n"
	$Response insert end "  Major is [$response Major]\n"
	$Response insert end "  Minor is [$response Minor]\n"
	$Response insert end "  CommandStationType is [$response CommandStationType]\n"
    }
    COMMAND_STATION_STATUS {
	$Response insert end "Command Station Status\n"
	$Response insert end "  EmergencyOff is [$response EmergencyOff]\n"
	$Response insert end "  EmergencyStop is [$response EmergencyStop]\n"
	$Response insert end "  StartMode is [$response StartMode]\n"
	$Response insert end "  ServiceMode is [$response ServiceMode]\n"
	$Response insert end "  PoweringUp is [$response PoweringUp]\n"
	$Response insert end "  RAMCheckError is [$response RAMCheckError]\n"
    }
    TRANSFER_ERRORS {
	$Response insert end "Transfer Errors\n"
    }
    COMMAND_STATION_BUSY {
	$Response insert end "Command Station Busy\n"
    }
    INSTRUCTION_NOT_SUPPORTED {
	$Response insert end "Instruction Not Supported\n"
    }
    ACCESSORY_DECODER_INFORMATION {
	$Response insert end "Accessory Decoder Information\n"
	$Response insert end "  NumberOfFeedbackElements is [$response NumberOfFeedbackElements]\n"
	$Response insert end "  Address is [$response Address]\n"
	$Response insert end "  Completed is [$response Completed]\n"
	$Response insert end "  AccessoryType is [$response AccessoryType]\n"
	$Response insert end "  Nibble is [$response Nibble]\n"
	$Response insert end "  TurnoutStatus is [$response TurnoutStatus]\n"
    }
    LOCOMOTIVE_INFORMATION {
	#$Response insert end "Locomotive Information\n"
	#$Response insert end "  Address is [$response Address]\n"
	#$Response insert end "  Available is [$response Available]\n"
	#$Response insert end "  Direction is [$response Direction]\n"
	# Set Direction
	variable LocoDirection
	$LocoDirection direction_sense [$response Direction]
	#$Response insert end "  SpeedStepMode is [$response SpeedStepMode]\n"
	# Set Speed Step Mode
	variable LocoSpeedStep
	set index [lsearch [$LocoSpeedStep cget -values] [$response SpeedStepMode]]
	$LocoSpeedStep setvalue @$index
	#$Response insert end "  Speed is [$response Speed]\n"
	# Set Speed
	switch [$response SpeedStepMode] {
	  S14 {set S128 [expr {int((double([$response Speed]) / 14.0)*128)}]}
	  S27 {set S128 [expr {int((double([$response Speed]) / 27.0)*128)}]}
	  S28 {set S128 [expr {int((double([$response Speed]) / 28.0)*128)}]}
	  S128 {set S128 [$response Speed]}
	}
	variable LocoSpeed
	$LocoSpeed setspeed $S128
	variable Functions
	for {set i 0} {$i < 13} {incr i} {
	  #$Response insert end "[format {  Function %2d is } $i][$response Function $i]\n"
	  set Functions($i,value) [$response Function $i]
	  UpdateButtonColors
	}
	#$Response insert end "  MTR is [$response MTR]\n"
	#$Response insert end "  Address2 is [$response Address2]\n"
    }
    FUNCTION_STATUS {
	$Response insert end "Function Status\n"
	for {set i 0} {$i < 13} {incr i} {
	  $Response insert end "[format {  Status %2d is } $i][$response Status $i]\n"
	}
    }
    LOCOMOTIVE_ADDRESS {
	$Response in sert end "Locomotive Address\n"
	$Response insert end "  AddressType is [$response AddressType]\n"
	$Response insert end "  Address is [$response Address]\n"
    }
    DOUBLE_HEADER_INFORMATION {
	$Response insert end "Double Header Information\n"
	$Response insert end "  Address is [$response Address]\n"
	$Response insert end "  Available is [$response Available]\n"
	$Response insert end "  Direction is [$response Direction]\n"
	$Response insert end "  SpeedStepMode is [$response SpeedStepMode]\n"
	$Response insert end "  Speed is [$response Speed]\n"
	for {set i 0} {$i < 13} {incr i} {
	  $Response insert end "[format {  Function %2d is } $i][$response Function $i]\n"
	}
	$Response insert end "  Address2 is [$response Address2]\n"
	
    }
    DOUBLE_HEADER_MU_ERROR {
	$Response insert end "Double Header Mu Error\n"
	$Response insert end "  Error is [$response Error]\n"
    }
    LI100_MESSAGE {
	$Response insert end "Li100 Message\n"
	$Response insert end "  MessageType is [$response MessageType]\n"
    }
    LI100_VERSION {
	$Response insert end "Li100 VERSION\n"
	$Response insert end "  Hardware Version is [$response HardwareVersion]\n"
	$Response insert end "  Software Version is [$response SoftwareVersion]\n"
    }
    LI101_XPRESSNET_ADDRESS {
	$Response insert end "Li101 XPressNet Address\n"
	$Response insert end "  Address is [$response Address]\n"
    }
  }
  if {[llength $InstructionQueue] > 0} {
    set cmd [lindex $InstructionQueue 0]
    set InstructionQueue [lrange $InstructionQueue 1 end]
    uplevel #0 $cmd
    $Response insert end "$cmd\n"
  }
  $Response see end
}

proc XPressNetThrottle::QueueInstruction {args} {
  variable InstructionQueue
  lappend InstructionQueue $args
  if {[llength $InstructionQueue] < 2} {
    after 1000 XPressNetThrottle::ProcessResponse NO_RESPONSE_AVAILABLE NULL
  }
}

proc XPressNetThrottle::groupargorder {a b} {
  variable Functions
  return [expr {$Functions($a,arg) - $Functions($b,arg)}]
}

proc XPressNetThrottle::UpdateButtonColors {} {
  variable Functions
  for {set i 0} {$i < 13} {incr i} {
    if {$Functions($i,value) == 1} {
      $Functions($i,button) configure -fg red
      $Functions($i,button) configure -activeforeground red
    } else {
      $Functions($i,button) configure -fg black
      $Functions($i,button) configure -activeforeground black
    }
  }
}

proc XPressNetThrottle::toggleButton {i} {
  variable Functions
  variable FGroup
  variable LocoAddress
  set group $Functions($i,group)
  set glist $FGroup($group)

  if {$Functions($i,value) == 1} {
    set Functions($i,value) 0
    $Functions($i,button) configure -fg black
    $Functions($i,button) configure -activeforeground black
  } else {
    set Functions($i,value) 1
    $Functions($i,button) configure -fg red
    $Functions($i,button) configure -activeforeground red
  }

  set cmd [list XPressNetThrottle::QueueInstruction XPressNetThrottle::XPressNetBus]
  switch $group {
    1 {lappend cmd SetLocomotiveFunctionsGroup1}
    2 {lappend cmd SetLocomotiveFunctionsGroup2}
    3 {lappend cmd SetLocomotiveFunctionsGroup3}
  }
  lappend cmd [$LocoAddress currentLocomotive]
  foreach i $glist {
    lappend cmd $Functions($i,value)
  }
  puts stderr "*** XPressNetThrottle::selectFunction: cmd is $cmd"
  eval $cmd
}  

proc XPressNetThrottle::selectFunction {i} {
  variable Functions
  variable FGroup
  variable LocoAddress
  set group $Functions($i,group)
  set glist $FGroup($group)

  set cmd [list XPressNetThrottle::QueueInstruction XPressNetThrottle::XPressNetBus]
  switch $group {
    1 {lappend cmd SetLocomotiveFunctionsGroup1}
    2 {lappend cmd SetLocomotiveFunctionsGroup2}
    3 {lappend cmd SetLocomotiveFunctionsGroup3}
  }
  lappend cmd [$LocoAddress currentLocomotive]
  foreach i $glist {
    lappend cmd $Functions($i,value)
  }
  puts stderr "*** XPressNetThrottle::selectFunction: cmd is $cmd"
  eval $cmd
}


proc GetAllSerialPorts {} {
  set result {}
  switch $::tcl_platform(platform) {
    unix {
	## Glob is our friend under UNIX (assumes Linux actually...)
	set allports [lsort [glob -nocomplain /dev/ttyS* /dev/ttyUSB*]]
    }
    windows {
	## Brute force under mess-windows...
	set allports {}
	for {set i 1} {$i <= 99} {incr i} {
	  lappend allports [format {COM%d:} $i]
	}
    }
    macintosh {
	## Glob is *also* our friend under MacOSX
	set allports [list [glob -nocomplain /dev/tty.* /dev/cu.*]]
    }
  }
  foreach port $allports {
    puts stderr "*** GetAllSerialPorts: port = $port"
    if {[catch {open $port r} chan]} {continue}
    puts stderr "*** GetAllSerialPorts: chan = $chan"
    if {![catch {fconfigure $chan -mode}]} {lappend result $port}
    close $chan
  }
  return $result
}



# Process command line options.

global IsSlave
set IsSlave 0
global argcTest
set argcTest 0
global argc argv argv0
global XPressNet_Port
set XPressNet_Port {}

for {set ia 0} {$ia < $argc} {incr ia} {
  switch -glob -- "[lindex $argv $ia]" {
    -isslave* {
      set IsSlave 1
      incr argcTest
      fconfigure stdin -buffering line
      fconfigure stdout -buffering line
    }
    default {
      if {$XPressNet_Port eq ""} {
	set XPressNet_Port "[lindex $argv $ia]"
      } else {
	puts stderr "usage: $argv0 \[wish options\] \[SerialPort\]"
	exit 96
      }
    }
  }
}

XPressNetThrottle::MainWindow

if {$XPressNet_Port eq ""} {
  Dialog .openPort -title [_ "Open Serial Port"] -modal local -parent . \
			-transient yes -side bottom -bitmap questhead \
			-default 0 -cancel 1
  .openPort add -text [_m "Button|Open"]
  .openPort add -text [_m "Button|Cancel"]
  .openPort add -text [_m "Button|Help"] -command {HTMLHelp::HTMLHelp help {Open Port}}
  wm protocol .openPort WM_DELETE_WINDOW {.openPort enddialog 1}

  set uframe [.openPort getframe]
  pack [ComboBox $uframe.serialPort \
		-textvariable ::OpenPortState(Port) -editable yes \
		-values [GetAllSerialPorts]] -fill x
  set ::OpenPortState(Port) [lindex [$uframe.serialPort cget -values] 0]
  set result [.openPort draw]
  .openPort withdraw
  if {$result == 1} {
    tk_messageBox -type ok -icon warning -message "No serial port specified!"
    exit 99
  }
  set XPressNet_Port $::OpenPortState(Port)
}

xpressnet::XpressNetEvent XPressNetThrottle::XPressNetBus XPressNetThrottle::ProcessResponse $XPressNet_Port

$XPressNetThrottle::NoteBook raise throttle

