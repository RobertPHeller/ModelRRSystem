#* 
#* ------------------------------------------------------------------
#* SL2Test.src - Test program for SL2 units
#* Created by Robert Heller on Mon Oct 24 12:44:45 2011
#* ------------------------------------------------------------------
#* Modification History: $Log$
#* Modification History: Revision 1.1  2002/07/28 14:03:50  heller
#* Modification History: Add it copyright notice headers
#* Modification History:
#* ------------------------------------------------------------------
#* Contents:
#* ------------------------------------------------------------------
#*  
#*     Model RR System, Version 2
#*     Copyright (C) 1994,1995,2002-2005  Robert Heller D/B/A Deepwoods Software
#* 			51 Locke Hill Road
#* 			Wendell, MA 01379-9728
#* 
#*     This program is free software; you can redistribute it and/or modify
#*     it under the terms of the GNU General Public License as published by
#*     the Free Software Foundation; either version 2 of the License, or
#*     (at your option) any later version.
#* 
#*     This program is distributed in the hope that it will be useful,
#*     but WITHOUT ANY WARRANTY; without even the implied warranty of
#*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#*     GNU General Public License for more details.
#* 
#*     You should have received a copy of the GNU General Public License
#*     along with this program; if not, write to the Free Software
#*     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#* 
#*  
#* 

# $Id$

## @defgroup SL2Test SL2Test
#  @brief SL2 test program
#
# @section SYNOPSIS
# 
# SL2Test [X11 Resource Options]
# 
# @section DESCRIPTION
#
# This program is a GUI program for testing SL2 units.  
#
# @section PARAMETERS 
# 
# none 
#  
# @section AUTHOR 
# Robert Heller \<heller\@deepsoft.com\>
#

set argv0 [file join  [file dirname [info nameofexecutable]] SL2Test]

package require Azatrax

package require gettext
package require Tk
package require BWidget
package require BWStdMenuBar
package require HTMLHelp

#puts stderr "*** class of . is [. cget -class]"

global HelpDir
set HelpDir [file join [file dirname [file dirname [file dirname \
							[info script]]]] Help]
#puts stderr "*** HelpDir = $HelpDir"
set msgfiles [::msgcat::mcload [file join [file dirname [file dirname [file dirname \
							[info script]]]] Messages]]
#puts stderr "*** msgfiles = $msgfiles"

if {[tk windowingsystem] eq "classic" || [tk windowingsystem] eq "aqua"} {
    bind Radiobutton_RO <Enter> {
	tk::ButtonEnter %W
    }
    bind Checkbutton_RO <Enter> {
	tk::ButtonEnter %W
    }
}
if {"windows" eq $tcl_platform(platform)} {
    bind Checkbutton_RO <Enter> {
	tk::CheckRadioEnter %W
    }

    bind Radiobutton_RO <Enter> {
	tk::CheckRadioEnter %W
    }
}
if {"x11" eq [tk windowingsystem]} {
    bind Checkbutton_RO <Enter> {
	tk::ButtonEnter %W
    }
    bind Radiobutton_RO <Enter> {
	tk::ButtonEnter %W
    }
}

bind Checkbutton_RO <FocusIn> {}
bind Checkbutton_RO <Leave> {
    tk::ButtonLeave %W
}

bind Radiobutton_RO <FocusIn> {}
bind Radiobutton_RO <Leave> {
    tk::ButtonLeave %W
}



proc MainWindow {} {

  # Window manager configurations
  wm minsize . 300 1
  wm protocol . WM_DELETE_WINDOW {CareFulExit}
  wm title . [_ "SL2 Test Program for SL2 Units"]

  set menubar [StdMenuBar::MakeMenu \
	-file [list [_m "Menu|&File"] {file} {file} 0 [list \
	        [list command [_m "Menu|File|&New"]     {file:new} ""     {Ctrl n} -state disabled]\
	        [list command [_m "Menu|File|&Open..."] {file:open} [_ "Open Unit"] {Ctrl o} -command {OpenUnit}]\
	        [list command [_m "Menu|File|&Save"]    {file:save} "" {Ctrl s} -state disabled]\
		[list command [_m "Menu|File|Save &As..."] {file:save} "" {Ctrl a} -state disabled]\
	        [list command [_m "Menu|File|&Close"] {file:close} [_ "Close Unit"] {} -command {CloseUnit} -state disabled]\
	        [list command [_m "Menu|File|E&xit"] {file:exit} [_ "Exit the application"] {} -command {CareFulExit}]\
	     ] \
	] -help [list [_m "Menu|&Help"] {help} {help} 0 [list \
		[list command [_m "Menu|Help|On &Help..."] {help:help} [_ "Help on help"] {} -command "HTMLHelp::HTMLHelp help Help"]\
		[list command [_m "Menu|Help|On &Version"] {help:version} [_ "Version"] {} -command "HTMLHelp::HTMLHelp help Version"]\
		[list command [_m "Menu|Help|Warranty"] {help:warranty} [_ "Warranty"] {} -command "HTMLHelp::HTMLHelp help Warranty"]\
		[list command [_m "Menu|Help|Copying"] {help:copying} [_ "Copying"] {} -command "HTMLHelp::HTMLHelp help Copying"]\
		[list command [_m "Menu|Help|Reference Manual"] {help:reference} [_ "Reference Manual"] {} -command {HTMLHelp::HTMLHelp help "SL2 Test Program Reference"}]\
		] \
        ]]
#  puts stderr "*** MainWindow: menubar = $menubar"
#  foreach x $menubar {
#    puts stderr [list *** x = $x]
#  }

  set ::Main [MainFrame .main -menu $menubar \
	-progressmax 100 -progresstype normal -progressvar ::progress \
	-textvariable status \
	-separator both]
  pack $::Main -expand yes -fill both
  $::Main showstatusbar progression

  set ::MainFrame [$::Main getframe]

  HTMLHelp::HTMLHelp setDefaults "$::HelpDir" "AzatraxProgli1.html"

  LabelFrame $::MainFrame.snframe -width 22 -text "Serial Number To open:"
  pack $::MainFrame.snframe -fill x
  set snframe [$::MainFrame.snframe getframe]
  set ::SerialNumber [ComboBox $snframe.serialNumber \
				-editable yes \
				-values [Azatrax_AllConnectedDevices]]
  pack $::SerialNumber -side left -fill x -expand yes
  $::SerialNumber bind <Return> {OpenUnit}
  set rescan [Button $snframe.rescan -text "Rescan" \
			-command {$::SerialNumber configure -values [Azatrax_AllConnectedDevices]}]
  pack $rescan -side right

  # build widget $::MainFrame.commands
  labelframe $::MainFrame.commands \
    -borderwidth {4} \
    -relief {ridge} \
    -text {Commands}

  pack configure $::MainFrame.commands -fill x

  # Row 1
  button $::MainFrame.commands.setQ1PosQ2Neg \
	-text "Set Q1 Positive, Q2 Negative" \
	-command {catch {sl2unit SetQ1posQ2neg} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ1PosQ2Neg -column 0  -row 0 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ1PosQ2Neg
  button $::MainFrame.commands.setQ1NegQ2Pos \
	-text "Set Q1 Negative, Q2 Positive" \
	-command {catch {sl2unit SetQ1negQ2pos} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ1NegQ2Pos -column 1  -row 0 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ1Neg2Pos

  button $::MainFrame.commands.setQ1Q2open \
	-text "Set Q1 and Q2 Open" \
	-command {catch {sl2unit SetQ1Q2open} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ1Q2open -column 2  -row 0 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ1Q2open

  # Row 2
  button $::MainFrame.commands.setQ3PosQ4Neg \
	-text "Set Q3 Positive, Q4 Negative" \
	-command {catch {sl2unit SetQ3posQ4neg} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ3PosQ4Neg -column 0  -row 1 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ3PosQ4Neg
  button $::MainFrame.commands.setQ3NegQ4Pos \
	-text "Set Q3 Negative, Q4 Positive" \
	-command {catch {sl2unit SetQ3negQ4pos} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ3NegQ4Pos -column 1  -row 1 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ3NegQ4Pos

  button $::MainFrame.commands.setQ3Q4open \
	-text "Set Q3 and Q4 Open" \
	-command {catch {sl2unit SetQ3Q4open} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.setQ3Q4open -column 2  -row 1 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.setQ3Q4open

  # Row 3
  button $::MainFrame.commands.restoreLEDs \
	-text "Restore LEDs" \
	-command {catch {sl2unit RestoreLEDFunction} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.restoreLEDs -column 0 -row 2 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.restoreLEDs
  button $::MainFrame.commands.id1 \
	-text "Identify 1" \
	-command {catch {sl2unit Identify_1} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.id1 -column 1 -columnspan 2 -row 2 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.id1

  # Row 4
  button $::MainFrame.commands.enableInputs \
	-text "Enable/Disable Inputs" \
	-command {catch {sl2unit OutputRelayInputControl $::I1 $::I2 $::I3 $::I4} ::status} \
	-state disabled
  grid configure $::MainFrame.commands.enableInputs -column 0 -row 3 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.enableInputs
  frame $::MainFrame.commands.enableInputButtons
  grid configure $::MainFrame.commands.enableInputButtons -column 1 -columnspan 2 -row 3 -sticky we
  foreach rb {in1 in2 in3 in4} rv {::I1 ::I2 ::I3 ::I4} rl {{Input 1} {Input 2} {Input 3} {Input 4}} {
    checkbutton $::MainFrame.commands.enableInputButtons.$rb \
		-text $rl -offvalue false -onvalue true -variable $rv \
		-state disabled
    pack $::MainFrame.commands.enableInputButtons.$rb -side left -expand yes -fill x
    lappend ::CommandButtons $::MainFrame.commands.enableInputButtons.$rb
    set $rv true
  }

  # Row 6
  button $::MainFrame.commands.getStateData \
	-text "Get Sense Data" \
	-command {if {![catch {sl2unit GetStateData} ::status]} {UpdateSenseData}} \
	-state disabled
  grid configure $::MainFrame.commands.getStateData -column 0 -row 5 -sticky we
  lappend ::CommandButtons $::MainFrame.commands.getStateData

  # build widget $::MainFrame.sensedata
  labelframe $::MainFrame.sensedata \
    -borderwidth {4} \
    -relief {ridge} \
    -text {Sense Data}

  pack configure $::MainFrame.sensedata -fill x

  LabelEntry $::MainFrame.sensedata.packetCount \
	-labelwidth 22 \
	-label "Packet Count" \
	-editable no -text 0
  pack $::MainFrame.sensedata.packetCount -fill x
  LabelFrame $::MainFrame.sensedata.motor1Status \
	-width 22 -text "Motor 1 (Q1&Q2) Status"
  pack $::MainFrame.sensedata.motor1Status -fill x
  set m1sframe [$::MainFrame.sensedata.motor1Status getframe]
  foreach rb    {m1dir_neg m1dir_pos m1state_off m1state_on} \
	  rbLab {{Q1 Neg} {Q1 Pos} {Motor Off} {Motor On}} \
	  rbVar {::senseLatch(M1,Dir) ::senseLatch(M1,Dir) ::senseLatch(M1,State) ::senseLatch(M1,State)} \
	  rbVal {0 1 0 1} {
    set b [radiobutton $m1sframe.$rb -variable $rbVar -text $rbLab \
			-value $rbVal -relief flat]
    pack $b -side left -expand yes -fill x
    set tags [bindtags $b]
    set i [lsearch -exact $tags Radiobutton]
    if {$i >= 0} {
      bindtags $b [lreplace $tags $i $i Radiobutton_RO]
    }
  }
  LabelFrame $::MainFrame.sensedata.motor2Status \
	-width 22 -text "Motor 2 (Q3&Q4) Status"
  pack $::MainFrame.sensedata.motor2Status -fill x
  set m2sframe [$::MainFrame.sensedata.motor2Status getframe]
  foreach rb    {m2dir_neg m2dir_pos m2state_off m2state_on} \
	  rbLab {{Q3 Neg} {Q3 Pos} {Motor Off} {Motor On}} \
	  rbVar {::senseLatch(M2,Dir) ::senseLatch(M2,Dir) ::senseLatch(M2,State) ::senseLatch(M2,State)} \
	  rbVal {0 1 0 1} {
    set b [radiobutton $m2sframe.$rb -variable $rbVar -text $rbLab \
			-value $rbVal -relief flat]
    pack $b -side left -expand yes -fill x
    set tags [bindtags $b]
    set i [lsearch -exact $tags Radiobutton]
    if {$i >= 0} {
      bindtags $b [lreplace $tags $i $i Radiobutton_RO]
    }
  }
  LabelFrame $::MainFrame.sensedata.inputSense \
	-width 22 -text "Input sense"
  pack $::MainFrame.sensedata.inputSense -fill x
  set isframe [$::MainFrame.sensedata.inputSense getframe] 
  foreach rb    {i1 i2 i3 i4} rbLab {I1 I2 I3 I4} \
	  rbVar {::senseLatch(I1,sense) ::senseLatch(I2,sense) ::senseLatch(I3,sense) ::senseLatch(I4,sense)} {
    set b [radiobutton $isframe.$rb -variable $rbVar -text $rbLab \
		-value 1 -relief flat]
    pack $b -side left -expand yes -fill x
    set tags [bindtags $b]
    set i [lsearch -exact $tags Radiobutton]
    if {$i >= 0} {
      bindtags $b [lreplace $tags $i $i Radiobutton_RO]
    }
  }
  LabelFrame $::MainFrame.sensedata.inputEnable \
	-width 22 -text "Input enabled"
  pack $::MainFrame.sensedata.inputEnable -fill x
  set ieframe [$::MainFrame.sensedata.inputEnable getframe] 
  foreach rb    {i1 i2 i3 i4} rbLab {I1 I2 I3 I4} \
	  rbVar {::senseLatch(I1,enabled) ::senseLatch(I2,enabled) ::senseLatch(I3,enabled) ::senseLatch(I4,enabled)} {
    set b [radiobutton $ieframe.$rb -variable $rbVar -text $rbLab \
		-value 1 -relief flat]
    pack $b -side left -expand yes -fill x
    set tags [bindtags $b]
    set i [lsearch -exact $tags Radiobutton]
    if {$i >= 0} {
      bindtags $b [lreplace $tags $i $i Radiobutton_RO]
    }
  }
  LabelEntry $::MainFrame.sensedata.serialNumber \
	-labelwidth 22 -label "Unit Serial Number:" -editable no
  pack $::MainFrame.sensedata.serialNumber -fill x

  set w .
  global IsSlave
  if {!$IsSlave} {
    wm withdraw $w
    update idletasks
    set rw [winfo reqwidth $w]
    if {$rw < 200} {set rw 300}
    set rh [winfo reqheight $w]
    set x [expr {[winfo screenwidth $w]/2 - $rw/2 \
            - [winfo vrootx $w]}]
    set y [expr {[winfo screenheight $w]/2 - $rh/2 \
            - [winfo vrooty $w]}]
    wm geom $w =${rw}x${rh}+$x+$y
    wm deiconify .
  }
  update idletasks
  wm minsize . [winfo reqwidth $w] [expr [winfo reqheight $w] + 35]
  bind all <q> CareFulExit
  bind all <Q> CareFulExit
}

proc CareFulExit {} {
# Procedure to carefully exit.
# [index] CarefulExit!procedure

  if {[string compare \
        [tk_messageBox -default no -icon question -message [_ "Really Quit?"] \
                -title [_ "Careful Exit"] -type yesno] {yes}] == 0} {
    global IsSlave
    #puts stderr "*** CarefulExit: IsSlave = $IsSlave"
    flush stderr
    if {$IsSlave} {
      puts stdout "101 Exit"
      flush stdout
      set ans [gets stdin]
      #puts stderr "*** CarefulExit: ans = '$ans'"
    }
    if {[llength [info command sl2unit]] > 0} {
      CloseUnit 0
    }
    exit
  }
}

# Open a selected unit...
proc OpenUnit {} {

  set serialnumber [$::SerialNumber cget -text]

#  puts stderr "*** OpenUnit: serialnumber is '$serialnumber'"

#  puts stderr "*** OpenUnit: info command sl2unit = [info command sl2unit]"

  if {[llength [info command sl2unit]] > 0} {
    CloseUnit
  }

  
  if {[string length "$serialnumber"] != 0} {
    if {[catch {SL2 sl2unit -this [Azatrax_OpenDevice "$serialnumber" $::Azatrax_idSL2Product]} errormessage]} {
#      puts stderr "*** OpenUnit: errormessage = $errormessage"
      catch {rename sl2unit {}}
      set ::status [_ "Failed to open unit because %s." errormessage]
      tk_messageBox -icon error -message "$errormessage" -type ok
    } else {
#      puts stderr "*** OpenUnit: Serial Number is [sl2unit SerialNumber]"
      foreach b $::CommandButtons {$b configure -state normal}
      $::Main setmenustate file:close normal
      if {![catch {sl2unit GetStateData} ::status]} {
	UpdateSenseData
      }
    }
  }
}

proc CloseUnit {{messageP 1}} {
  foreach b $::CommandButtons {$b configure -state disabled}
  $::Main setmenustate file:close disabled
  catch {rename sl2unit {}}
  if {$messageP} {
    tk_messageBox -icon info -message [_ "Unit %s closed." [$::MainFrame.sensedata.serialNumber cget -text]]
  }
}

proc UpdateSenseData {} {
  $::MainFrame.sensedata.packetCount configure -text [sl2unit PacketCount]
  set ::senseLatch(M1,Dir) [sl2unit Motor_1_Direction]
  set ::senseLatch(M1,State) [sl2unit Motor_1_State]
  set ::senseLatch(M2,Dir) [sl2unit Motor_2_Direction]
  set ::senseLatch(M2,State) [sl2unit Motor_2_State]
  set ::senseLatch(I1,sense) [sl2unit Sense_1]
  set ::senseLatch(I2,sense) [sl2unit Sense_2]
  set ::senseLatch(I3,sense) [sl2unit Sense_3]
  set ::senseLatch(I4,sense) [sl2unit Sense_4]
  set ::senseLatch(I1,enabled) [sl2unit Input_1_Enabled]
  set ::senseLatch(I2,enabled) [sl2unit Input_2_Enabled]
  set ::senseLatch(I3,enabled) [sl2unit Input_3_Enabled]
  set ::senseLatch(I4,enabled) [sl2unit Input_4_Enabled]
  $::MainFrame.sensedata.serialNumber configure -text [sl2unit SerialNumber]
}

array set ::senseLatch {
  M1,Dir 0
  M1,State 0
  M2,Dir 0
  M2,State 0
  I1,sense 0
  I2,sense 0
  I3,sense 0
  I4,sense 0
  I1,enabled 0
  I2,enabled 0
  I3,enabled 0
  I4,enabled 0
}

# Process command line options.

global IsSlave
set IsSlave 0
global argcTest
set argcTest 0
global argc argv argv0

for {set ia 0} {$ia < $argc} {incr ia} {
  switch -glob -- "[lindex $argv $ia]" {
    -isslave* {
      set IsSlave 1
      incr argcTest
      fconfigure stdin -buffering line
      fconfigure stdout -buffering line
    }
    default {
      puts stderr "usage: $argv0 \[wish options\]"
      exit 96
    }
  }
}

MainWindow
